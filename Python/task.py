

def bfs( x, y, N):

    inf = 200

    mp = [ [inf] * N ] * N
    
    for i in range(N):      #/?????????????????????????????????????????????????????/
        print(mp[i])        #/?????????????????????????????????????????????????????/
                            #/????????????/WHAT/???????????????????????????????????/
    print(mp[y][x])         #/??????????????/THE/??????????????????????????????????/
    mp[y][x] = 0            #/????????????????/FUCKING/????????????????????????????/
    print(mp[y][x])         #/???????????????????/FUCK/??????/HAATE IT/????????????/
                            #/?????????/WHAT'S/????????????????????????????????????/ 
    for i in range(N):      #/????????????/WRONG/??????????????????????????????????/
        print(mp[i])        #/?????????????????????????????????????????????????????/

    steps = [(1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2)] #(x,y)

    q = []
    q.append( ( y, x) )

    while q:
        
        print(q)  
        v = q.pop(0)

        for (i,j) in steps:
            
            crx, cry = v[1] + i, v[0] + j

            if (N > cry >= 0) and (N > crx >= 0) and (mp[cry][crx] == inf):

                q.append( ( cry, crx) )
                mp[cry][crx] = mp[ v[0] ][ v[1] ] + 1
         
    return mp




def main():

    N = int(input())
    s = [ int(x) for x in input().split() ]
    e = [ int(x) for x in input().split() ]

    print( bfs( s[0] - 1, s[1] - 1, N)[e[0] - 1][e[1] - 1] )

    
main()
